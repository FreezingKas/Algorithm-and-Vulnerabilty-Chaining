from Vulnerability import Vulnerability


def vulnerability_chainer(vulns_object: list) -> float:
    """
    Create a chain of many vulnerabilities and print the basescore of this chain
    :param vulns_object:
    :return: parameters list of the vulnerability
    """

    # sort vulnerabilities by their efficiency : Impact/Exploitability
    result = sorted(vulns_object, key=Vulnerability.get_efficiency_impact_exploitability)

    # meta list of minimize and maxmize
    meta_list = ["", "high", "high", "required", "unchanged", "none", "none", "none"]
    meta_list[0] = result[0].get_attack_vector()

    # for all vuln i maximize or minimize their value with paramters int the chain
    for vuln in result:
        # minimize
        AC_value = {"low": 1, "high": 2}
        if AC_value[vuln.get_attack_complexity()] < AC_value[meta_list[1]]:
            meta_list[1] = vuln.get_attack_complexity()

        # minimize
        PR_value = {"none": 1, "low": 2, "high": 3}
        if PR_value[vuln.get_privileges_required()] < PR_value[meta_list[2]]:
            meta_list[2] = vuln.get_privileges_required()

        # minimize
        UI_value = {"none": 1, "required": 2}
        if UI_value[vuln.get_user_interaction()] < UI_value[meta_list[3]]:
            meta_list[3] = vuln.get_user_interaction()

        if vuln.get_scope() == "changed":
            meta_list[4] = "changed"

        # maximize
        impact_value = {"none": 1, "low": 2, "high": 3}
        if impact_value[vuln.get_confidentiality_impact()] > impact_value[meta_list[5]]:
            meta_list[5] = vuln.get_confidentiality_impact()

        if impact_value[vuln.get_integrity_impact()] > impact_value[meta_list[6]]:
            meta_list[6] = vuln.get_integrity_impact()

        if impact_value[vuln.get_availability_impact()] > impact_value[meta_list[7]]:
            meta_list[7] = vuln.get_availability_impact()

    meta_vuln = Vulnerability(meta_list)
    return meta_vuln.get_basescore()
